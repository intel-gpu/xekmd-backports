From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Dominik Grzegorzek <dominik.grzegorzek@intel.com>
Date: Fri, 14 Jun 2024 12:23:35 +0200
Subject: drm/xe/eudebug/ptl: Add support for extra attention register

xe3 can set bits within an additional attention bit register EU_ATT1.
Recalculate bitmask and make sure we read all required data.

v2: Do not assume that attention registers are placed one after other.
v3: remove xe_device_types dependencay (Christoph)

Signed-off-by: Dominik Grzegorzek <dominik.grzegorzek@intel.com>
Signed-off-by: Mika Kuoppala <mika.kuoppala@linux.intel.com>
Signed-off-by: Christoph Manszewski <christoph.manszewski@intel.com>
Reviewed-by: Maciej Patelczyk <maciej.patelczyk@intel.com>
(cherry-picked from commit d09a2d1b7c87bba62ccb4b8436baa47c1080732d drm-tip-eudebug)
Signed-off-by: Bommu Krishnaiah <krishnaiah.bommu@intel.com>
---
 drivers/gpu/drm/xe/regs/xe_gt_regs.h |  4 +-
 drivers/gpu/drm/xe/xe_eudebug.c      | 82 +++++++++++++++-------------
 drivers/gpu/drm/xe/xe_gt_debug.c     | 47 +++++++++-------
 drivers/gpu/drm/xe/xe_gt_debug.h     | 16 +++++-
 4 files changed, 88 insertions(+), 61 deletions(-)

diff --git a/drivers/gpu/drm/xe/regs/xe_gt_regs.h b/drivers/gpu/drm/xe/regs/xe_gt_regs.h
index c2b817f617e4..bfe5f8e8dc26 100644
--- a/drivers/gpu/drm/xe/regs/xe_gt_regs.h
+++ b/drivers/gpu/drm/xe/regs/xe_gt_regs.h
@@ -486,7 +486,7 @@
 #define   DISABLE_ECC				REG_BIT(5)
 #define   ENABLE_PREFETCH_INTO_IC		REG_BIT(3)
 
-#define EU_ATT(x)				XE_REG_MCR(0xe470 + (x) * 4)
+#define EU_ATT(reg, row)			XE_REG_MCR((reg ? 0xe478 : 0xe470) + (row) * 4)
 
 #define ROW_CHICKEN4				XE_REG_MCR(0xe48c, XE_REG_OPTION_MASKED)
 #define   DISABLE_GRF_CLEAR			REG_BIT(13)
@@ -497,7 +497,7 @@
 #define   THREAD_EX_ARB_MODE			REG_GENMASK(3, 2)
 #define   THREAD_EX_ARB_MODE_RR_AFTER_DEP	REG_FIELD_PREP(THREAD_EX_ARB_MODE, 0x2)
 
-#define EU_ATT_CLR(i)				XE_REG_MCR(0xe490 + (i) * 4)
+#define EU_ATT_CLR(reg, row)			XE_REG_MCR((reg ? 0xe698 : 0xe490) + (row) * 4)
 
 #define ROW_CHICKEN3				XE_REG_MCR(0xe49c, XE_REG_OPTION_MASKED)
 #define   XE2_EUPEND_CHK_FLUSH_DIS		REG_BIT(14)
diff --git a/drivers/gpu/drm/xe/xe_eudebug.c b/drivers/gpu/drm/xe/xe_eudebug.c
index 7ab1f31e3535..d27838d0e8ca 100644
--- a/drivers/gpu/drm/xe/xe_eudebug.c
+++ b/drivers/gpu/drm/xe/xe_eudebug.c
@@ -1876,29 +1876,31 @@ static int check_attn_mcr(struct xe_gt *gt, void *data,
 {
 	struct ss_iter *iter = data;
 	struct xe_eudebug *d = iter->debugger;
-	unsigned int row;
+	unsigned int reg, row;
 
-	for (row = 0; row < XE_GT_EU_ATT_ROWS; row++) {
-		u32 val, cur = 0;
+	for (reg = 0; reg < xe_gt_eu_att_regs(gt); reg++) {
+		for (row = 0; row < XE_GT_EU_ATT_ROWS; row++) {
+			u32 val, cur = 0;
 
-		if (iter->i >= iter->size)
-			return 0;
+			if (iter->i >= iter->size)
+				return 0;
 
-		if (XE_WARN_ON((iter->i + sizeof(val)) >
-				(xe_gt_eu_attention_bitmap_size(gt))))
-			return -EIO;
+			if (XE_WARN_ON((iter->i + sizeof(val)) >
+					(xe_gt_eu_attention_bitmap_size(gt))))
+				return -EIO;
 
-		memcpy(&val, &iter->bits[iter->i], sizeof(val));
-		iter->i += sizeof(val);
+			memcpy(&val, &iter->bits[iter->i], sizeof(val));
+			iter->i += sizeof(val);
 
-		if (present)
-			cur = xe_gt_mcr_unicast_read(gt, EU_ATT(row), group, instance);
+			if (present)
+				cur = xe_gt_mcr_unicast_read(gt, EU_ATT(reg, row), group, instance);
 
-		if ((val | cur) != cur) {
-			eu_dbg(d,
-			       "WRONG CLEAR (%u:%u:%u) EU_ATT_CLR: 0x%08x; EU_ATT: 0x%08x\n",
-			       group, instance, row, val, cur);
-			return -EINVAL;
+			if ((val | cur) != cur) {
+				eu_dbg(d,
+				       "WRONG CLEAR (%u:%u:%u:%u) EU_ATT_CLR: 0x%08x; EU_ATT: 0x%08x\n",
+				       group, instance, reg, row, val, cur);
+				return -EINVAL;
+			}
 		}
 	}
 
@@ -1910,35 +1912,37 @@ static int clear_attn_mcr(struct xe_gt *gt, void *data,
 {
 	struct ss_iter *iter = data;
 	struct xe_eudebug *d = iter->debugger;
-	unsigned int row;
+	unsigned int reg, row;
 
-	for (row = 0; row < XE_GT_EU_ATT_ROWS; row++) {
-		u32 val;
+	for (reg = 0; reg < xe_gt_eu_att_regs(gt); reg++) {
+		for (row = 0; row < XE_GT_EU_ATT_ROWS; row++) {
+			u32 val;
 
-		if (iter->i >= iter->size)
-			return 0;
+			if (iter->i >= iter->size)
+				return 0;
 
-		if (XE_WARN_ON((iter->i + sizeof(val)) >
-				(xe_gt_eu_attention_bitmap_size(gt))))
-			return -EIO;
+			if (XE_WARN_ON((iter->i + sizeof(val)) >
+					(xe_gt_eu_attention_bitmap_size(gt))))
+				return -EIO;
 
-		memcpy(&val, &iter->bits[iter->i], sizeof(val));
-		iter->i += sizeof(val);
+			memcpy(&val, &iter->bits[iter->i], sizeof(val));
+			iter->i += sizeof(val);
 
-		if (!val)
-			continue;
+			if (!val)
+				continue;
 
-		if (present) {
-			xe_gt_mcr_unicast_write(gt, EU_ATT_CLR(row), val,
-						group, instance);
+			if (present) {
+				xe_gt_mcr_unicast_write(gt, EU_ATT_CLR(reg, row), val,
+							group, instance);
 
-			eu_dbg(d,
-			       "EU_ATT_CLR: (%u:%u:%u): 0x%08x\n",
-			       group, instance, row, val);
-		} else {
-			eu_warn(d,
-				"EU_ATT_CLR: (%u:%u:%u): 0x%08x to fused off dss\n",
-				group, instance, row, val);
+				eu_dbg(d,
+				       "EU_ATT_CLR: (%u:%u:%u:%u): 0x%08x\n",
+				       group, instance, reg, row, val);
+			} else {
+				eu_warn(d,
+					"EU_ATT_CLR: (%u:%u:%u:%u): 0x%08x to fused off dss\n",
+					group, instance, reg, row, val);
+			}
 		}
 	}
 
diff --git a/drivers/gpu/drm/xe/xe_gt_debug.c b/drivers/gpu/drm/xe/xe_gt_debug.c
index 9a6edbd08d67..314eef6734c3 100644
--- a/drivers/gpu/drm/xe/xe_gt_debug.c
+++ b/drivers/gpu/drm/xe/xe_gt_debug.c
@@ -13,6 +13,11 @@
 #include "xe_pm.h"
 #include "xe_macros.h"
 
+unsigned int xe_gt_eu_att_regs(struct xe_gt *gt)
+{
+	return (GRAPHICS_VERx100(gt_to_xe(gt)) >= 3000) ? 2u : 1u;
+}
+
 int xe_gt_foreach_dss_group_instance(struct xe_gt *gt,
 				     int (*fn)(struct xe_gt *gt,
 					       void *data,
@@ -59,18 +64,20 @@ int xe_gt_foreach_dss_group_instance(struct xe_gt *gt,
 static int read_first_attention_mcr(struct xe_gt *gt, void *data,
 				    u16 group, u16 instance, bool present)
 {
-	unsigned int row;
+	unsigned int reg, row;
 
 	if (!present)
 		return 0;
 
-	for (row = 0; row < 2; row++) {
-		u32 val;
+	for (reg = 0; reg < xe_gt_eu_att_regs(gt); reg++) {
+		for (row = 0; row < XE_GT_EU_ATT_ROWS; row++) {
+			u32 val;
 
-		val = xe_gt_mcr_unicast_read(gt, EU_ATT(row), group, instance);
+			val = xe_gt_mcr_unicast_read(gt, EU_ATT(reg, row), group, instance);
 
-		if (val)
-			return 1;
+			if (val)
+				return 1;
+		}
 	}
 
 	return 0;
@@ -94,7 +101,7 @@ int xe_gt_eu_attention_bitmap_size(struct xe_gt *gt)
 		  gt->fuse_topo.g_dss_mask, XE_MAX_DSS_FUSE_BITS);
 
 	return (find_last_bit(dss_mask, XE_MAX_DSS_FUSE_BITS) + 1) *
-		XE_GT_EU_ATT_ROWS * MAX_THREADS *
+		XE_GT_EU_ATT_ROWS * xe_gt_eu_att_regs(gt) * MAX_THREADS *
 		MAX_EUS_PER_ROW / 8;
 }
 
@@ -109,23 +116,25 @@ static int read_eu_attentions_mcr(struct xe_gt *gt, void *data,
 				  u16 group, u16 instance, bool present)
 {
 	struct attn_read_iter * const iter = data;
-	unsigned int row;
+	unsigned int reg, row;
 
-	for (row = 0; row < XE_GT_EU_ATT_ROWS; row++) {
-		u32 val;
+	for (reg = 0; reg < xe_gt_eu_att_regs(gt); reg++) {
+		for (row = 0; row < XE_GT_EU_ATT_ROWS; row++) {
+			u32 val;
 
-		if (iter->i >= iter->size)
-			return 0;
+			if (iter->i >= iter->size)
+				return 0;
 
-		XE_WARN_ON(iter->i + sizeof(val) > xe_gt_eu_attention_bitmap_size(gt));
+			XE_WARN_ON(iter->i + sizeof(val) > xe_gt_eu_attention_bitmap_size(gt));
 
-		if (present)
-			val = xe_gt_mcr_unicast_read(gt, EU_ATT(row), group, instance);
-		else
-			val = 0;
+			if (present)
+				val = xe_gt_mcr_unicast_read(gt, EU_ATT(reg, row), group, instance);
+			else
+				val = 0;
 
-		memcpy(&iter->bits[iter->i], &val, sizeof(val));
-		iter->i += sizeof(val);
+			memcpy(&iter->bits[iter->i], &val, sizeof(val));
+			iter->i += sizeof(val);
+		}
 	}
 
 	return 0;
diff --git a/drivers/gpu/drm/xe/xe_gt_debug.h b/drivers/gpu/drm/xe/xe_gt_debug.h
index d91d1f27b764..f882770e18d3 100644
--- a/drivers/gpu/drm/xe/xe_gt_debug.h
+++ b/drivers/gpu/drm/xe/xe_gt_debug.h
@@ -6,11 +6,25 @@
 #ifndef __XE_GT_DEBUG_
 #define __XE_GT_DEBUG_
 
-#include "xe_gt_types.h"
+#include <linux/bits.h>
+#include <linux/math.h>
+
+struct xe_gt;
 
 #define XE_GT_ATTENTION_TIMEOUT_MS 100
 #define XE_GT_EU_ATT_ROWS 2u
 
+struct xe_eu_attentions {
+#define XE_MAX_EUS 1024
+#define XE_MAX_THREADS 10
+
+	u8 att[DIV_ROUND_UP(XE_MAX_EUS * XE_MAX_THREADS, BITS_PER_BYTE)];
+	unsigned int size;
+	ktime_t ts;
+};
+
+unsigned int xe_gt_eu_att_regs(struct xe_gt *gt);
+
 int xe_gt_eu_threads_needing_attention(struct xe_gt *gt);
 int xe_gt_foreach_dss_group_instance(struct xe_gt *gt,
 				     int (*fn)(struct xe_gt *gt,
-- 
2.43.0

