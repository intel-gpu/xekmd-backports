From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Jan Maslak <jan.maslak@intel.com>
Date: Wed, 10 Dec 2025 14:58:36 +0100
Subject: drm/xe/eudebug: Check attention bits only once in
 attention_scan_fn()

Previously, handle_gt_queued_pagefault() and xe_eudebug_handle_gt_attention()
each performed separate attention bit checks. This created a race window where
attention bits could change between the two checks, leading to inconsistent
event delivery.

The fix consolidates attention checking to a single point in
attention_scan_fn(), ensuring atomic decision making for both event types.

Signed-off-by: Jan Maslak <jan.maslak@intel.com>
---
 drivers/gpu/drm/xe/prelim/xe_eudebug.c | 38 +++++++++++++++-----------
 1 file changed, 22 insertions(+), 16 deletions(-)

diff --git a/drivers/gpu/drm/xe/prelim/xe_eudebug.c b/drivers/gpu/drm/xe/prelim/xe_eudebug.c
index e831e36c7..66c0eaf85 100644
--- a/drivers/gpu/drm/xe/prelim/xe_eudebug.c
+++ b/drivers/gpu/drm/xe/prelim/xe_eudebug.c
@@ -1733,10 +1733,6 @@ static int xe_eudebug_handle_gt_attention(struct xe_gt *gt)
 {
 	int ret;
 
-	ret = prelim_xe_gt_eu_threads_needing_attention(gt);
-	if (ret <= 0)
-		return ret;
-
 	ret = xe_send_gt_attention(gt);
 
 	/* Discovery in progress, fake it */
@@ -1884,10 +1880,6 @@ static int handle_gt_queued_pagefault(struct xe_gt *gt)
 	struct xe_eudebug *d;
 	int ret, lrc_idx;
 
-	ret = prelim_xe_gt_eu_threads_needing_attention(gt);
-	if (ret <= 0)
-		return ret;
-
 	if (list_empty_careful(&gt_to_xe(gt)->eudebug.list))
 		return -ENOTCONN;
 
@@ -1922,6 +1914,16 @@ static int handle_gt_queued_pagefault(struct xe_gt *gt)
 	return ret;
 }
 
+static void _handle_attention_fail(struct xe_gt *gt, u8 gt_id, int ret)
+{
+	/* TODO: error capture */
+	drm_info(&gt_to_xe(gt)->drm,
+		 "gt:%d unable to handle eu attention ret=%d\n",
+		 gt_id, ret);
+
+	xe_gt_reset_async(gt);
+}
+
 #define XE_EUDEBUG_ATTENTION_INTERVAL 100
 static void attention_scan_fn(struct work_struct *work)
 {
@@ -1938,21 +1940,25 @@ static void attention_scan_fn(struct work_struct *work)
 
 	if (xe_pm_runtime_get_if_active(xe)) {
 		for_each_gt(gt, xe, gt_id) {
-			int ret;
+			int ret, attns_count;
 
 			if (gt->info.type != XE_GT_TYPE_MAIN)
 				continue;
 
-			handle_gt_queued_pagefault(gt);
+			attns_count = prelim_xe_gt_eu_threads_needing_attention(gt);
+			if (!attns_count)
+				continue;
 
-			ret = xe_eudebug_handle_gt_attention(gt);
+			ret = handle_gt_queued_pagefault(gt);
 			if (ret) {
-				// TODO: error capture
-				drm_info(&gt_to_xe(gt)->drm,
-					 "gt:%d unable to handle eu attention ret=%d\n",
-					 gt_id, ret);
+				_handle_attention_fail(gt, gt_id, ret);
+				continue;
+			}
 
-				xe_gt_reset_async(gt);
+			ret = xe_eudebug_handle_gt_attention(gt);
+			if (ret) {
+				_handle_attention_fail(gt, gt_id, ret);
+				continue;
 			}
 		}
 
-- 
2.34.1

