From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
Date: Wed, 26 Nov 2025 17:45:16 -0800
Subject: [PATCH 10/10] drm/xe/sriov: Add debugfs to set EQ and PT for
 scheduler groups

A top-level debugfs file is added that allows a user to provide a
comma-separated list of values to assign to each group. Per-group files
are also added to allow individual tuning of a specific group.

Signed-off-by: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
Cc: Michal Wajdeczko <michal.wajdeczko@intel.com>
---
 drivers/gpu/drm/xe/xe_gt_sriov_pf_debugfs.c | 173 +++++++++++++++++++-
 1 file changed, 168 insertions(+), 5 deletions(-)

diff --git a/drivers/gpu/drm/xe/xe_gt_sriov_pf_debugfs.c b/drivers/gpu/drm/xe/xe_gt_sriov_pf_debugfs.c
index 1efc0ae91..3ebcd3040 100644
--- a/drivers/gpu/drm/xe/xe_gt_sriov_pf_debugfs.c
+++ b/drivers/gpu/drm/xe/xe_gt_sriov_pf_debugfs.c
@@ -166,24 +166,169 @@ static void pf_add_policy_attrs(struct xe_gt *gt, struct dentry *parent)
  *              :   ├── gt0
  *                  :   ├── sched_groups_mode
  *                      ├── sched_groups
- *                      :   ├── group0
- *                          :   └── engines
+ *                      :   ├── exec_quantums_ms
+ *                          ├── preempt_timeouts_us
+ *                          ├── group0
+ *                          :   ├── engines
+ *                              ├── exec_quantum_ms
+ *                              └── preempt_timeout_us
  *                          :
  *                          └── groupN
- *          :                   └── engines
+ *                              ├── engines
+ *                              ├── exec_quantum_ms
+ *          :                   └── preempt_timeout_us
  *          ├── vf1
  *          :   ├── tile0
  *              :   ├── gt0
  *                  :   ├── sched_groups
- *                      :   ├── group0
- *                          :   └── engines
+ *                      :   ├── exec_quantums_ms
+ *                          ├── preempt_timeouts_us
+ *                          ├── group0
+ *                          :   ├── engines
+ *                              ├── exec_quantum_ms
+ *                              └── preempt_timeout_us
  */
 
 struct sched_group_info {
 	struct xe_gt *gt;
+	unsigned int vfid;
+	u8 group_id;
 	u32 *masks;
 };
 
+static int sched_groups_config_show(struct seq_file *m, void *data,
+				    void (*get)(struct xe_gt *, unsigned int, u32 *, u32))
+{
+	u32 values[GUC_KLV_VGT_POLICY_ENGINE_GROUP_MAX_COUNT];
+	struct drm_printer p = drm_seq_file_printer(m);
+	struct sched_group_info *groups = m->private;
+	struct xe_gt *gt = groups[0].gt;
+	unsigned int vfid = groups[0].vfid;
+	bool first = true;
+	u8 g;
+
+	get(gt, vfid, values, ARRAY_SIZE(values));
+
+	for (g = 0; g < ARRAY_SIZE(values); g++) {
+		drm_printf(&p, "%s%u", first ? "" : ",", values[g]);
+
+		first = false;
+	}
+
+	drm_printf(&p, "\n");
+
+	return 0;
+}
+
+#define MAX_EGS_ARRAY_SIZE (GUC_KLV_VGT_POLICY_ENGINE_GROUP_MAX_COUNT * sizeof(u32))
+static ssize_t sched_groups_config_write(struct file *file, const char __user *ubuf,
+					 size_t size, loff_t *pos,
+					 int (*set)(struct xe_gt *, unsigned int, u32 *, u32))
+{
+	struct sched_group_info *groups = file_inode(file)->i_private;
+	u32 values[GUC_KLV_VGT_POLICY_ENGINE_GROUP_MAX_COUNT];
+	struct xe_gt *gt = groups[0].gt;
+	unsigned int vfid = groups[0].vfid;
+	int *input;
+	u32 count;
+	int ret;
+	int i;
+
+	if (*pos)
+		return -ESPIPE;
+
+	if (!size)
+		return -ENODATA;
+
+	ret = parse_int_array_user(ubuf, min(size, MAX_EGS_ARRAY_SIZE), &input);
+	if (ret)
+		return ret;
+
+	count = input[0];
+	for (i = 0; i < count; i++) {
+		if (input[i + 1] < 0 || input[i + 1] > S32_MAX) {
+			ret = -EINVAL;
+			goto out;
+		}
+
+		values[i] = input[i + 1];
+	}
+
+	xe_pm_runtime_get(gt_to_xe(gt));
+	ret = set(gt, vfid, values, count);
+	xe_pm_runtime_put(gt_to_xe(gt));
+
+out:
+	kfree(input);
+	return (ret < 0) ? ret : size;
+}
+
+#define DEFINE_SRIOV_GT_GRP_CFG_DEBUGFS_ATTRIBUTE(CONFIG, TYPE, FORMAT)		\
+static int sched_groups_##CONFIG##s_show(struct seq_file *m,			\
+						  void *data)			\
+{										\
+	return sched_groups_config_show(m, data,				\
+					xe_gt_sriov_pf_config_get_groups_##CONFIG##s); \
+}										\
+										\
+static int sched_groups_##CONFIG##s_open(struct inode *inode, struct file *file)\
+{										\
+	return single_open(file, sched_groups_##CONFIG##s_show,			\
+			   inode->i_private);					\
+}										\
+										\
+static ssize_t sched_groups_##CONFIG##s_write(struct file *file,		\
+					      const char __user *ubuf,		\
+					      size_t size, loff_t *pos)		\
+{										\
+	return sched_groups_config_write(file, ubuf, size, pos,			\
+					 xe_gt_sriov_pf_config_set_groups_##CONFIG##s); \
+}										\
+										\
+static const struct file_operations sched_groups_##CONFIG##s_fops = {		\
+	.owner = THIS_MODULE,							\
+	.open = sched_groups_##CONFIG##s_open,					\
+	.read = seq_read,							\
+	.llseek = seq_lseek,							\
+	.write = sched_groups_##CONFIG##s_write,				\
+	.release = single_release,						\
+};										\
+										\
+static int group_##CONFIG##_set(void *data, u64 val)				\
+{										\
+	struct sched_group_info *gi = data;					\
+	struct xe_device *xe = gt_to_xe(gi->gt);				\
+	int err;								\
+										\
+	if (val > (TYPE)~0ull)							\
+		return -EOVERFLOW;						\
+										\
+	xe_pm_runtime_get(xe);							\
+	err = xe_sriov_pf_wait_ready(xe) ?:					\
+	      xe_gt_sriov_pf_config_set_group_##CONFIG(gi->gt, gi->vfid,	\
+						       gi->group_id, val);	\
+	if (!err)								\
+		xe_sriov_pf_provision_set_custom_mode(xe);			\
+	xe_pm_runtime_put(xe);							\
+										\
+	return err;								\
+}										\
+										\
+static int group_##CONFIG##_get(void *data, u64 *val)				\
+{										\
+	struct sched_group_info *gi = data;					\
+										\
+	*val = xe_gt_sriov_pf_config_get_group_##CONFIG(gi->gt, gi->vfid,	\
+							gi->group_id);		\
+	return 0;								\
+}										\
+										\
+DEFINE_DEBUGFS_ATTRIBUTE(group_##CONFIG##_fops, group_##CONFIG##_get,		\
+			 group_##CONFIG##_set, FORMAT)
+
+DEFINE_SRIOV_GT_GRP_CFG_DEBUGFS_ATTRIBUTE(exec_quantum, u32, "%llu\n");
+DEFINE_SRIOV_GT_GRP_CFG_DEBUGFS_ATTRIBUTE(preempt_timeout, u32, "%llu\n");
+
 static int sched_group_engines_info(struct seq_file *m, void *data)
 {
 	struct drm_printer p = drm_seq_file_printer(m);
@@ -262,6 +407,18 @@ static void sched_group_info_register(struct xe_gt *gt, unsigned int vfid)
 		goto out_err;
 	parent->d_inode->i_private = infos;
 
+	/*
+	 * assign group 0 gt and VF id values early as they're used by the
+	 * exec_quantums debugfs to set quantums for all groups
+	 */
+	infos[0].gt = gt;
+	infos[0].vfid = vfid;
+
+	debugfs_create_file("exec_quantums_ms", 0644, parent, infos,
+			    &sched_groups_exec_quantums_fops);
+	debugfs_create_file("preempt_timeouts_us", 0644, parent, infos,
+			    &sched_groups_preempt_timeouts_fops);
+
 	for (g = 0; g < num_groups; g++) {
 		struct sched_group_info *info = &infos[g];
 		u32 base = g * GUC_MAX_ENGINE_CLASSES;
@@ -274,10 +431,16 @@ static void sched_group_info_register(struct xe_gt *gt, unsigned int vfid)
 			goto out_err;
 
 		info->gt = gt;
+		info->vfid = vfid;
+		info->group_id = g;
 		info->masks = &policy->guc.sched_groups.modes[mode].masks[base];
 
 		dent->d_inode->i_private = info;
 		debugfs_create_file("engines", 0644, dent, info, &sched_group_engines_fops);
+		debugfs_create_file("exec_quantum_ms", 0644, dent, info,
+				    &group_exec_quantum_fops);
+		debugfs_create_file("preempt_timeout_us", 0644, dent, info,
+				    &group_preempt_timeout_fops);
 	}
 
 	return;
-- 
2.34.1

