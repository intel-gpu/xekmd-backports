From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Dominik Grzegorzek <dominik.grzegorzek@intel.com>
Date: Thu, 27 Nov 2025 13:44:26 +0100
Subject: drm/xe/eudebug/xe3: Add support for extra attention register

xe3 can set bits within an additional attention bit register EU_ATT1.
Recalculate bitmask and make sure we read all required data.

v2: Do not assume that attention registers are placed one after other.
v3: remove xe_device_types dependencay (Christoph)

Signed-off-by: Dominik Grzegorzek <dominik.grzegorzek@intel.com>
Signed-off-by: Mika Kuoppala <mika.kuoppala@linux.intel.com>
Signed-off-by: Christoph Manszewski <christoph.manszewski@intel.com>
Signed-off-by: Maciej Patelczyk <maciej.patelczyk@intel.com>
Reviewed-by: Maciej Patelczyk <maciej.patelczyk@intel.com>
---
 drivers/gpu/drm/xe/prelim/xe_eudebug.c  | 79 ++++++++++++++-----------
 drivers/gpu/drm/xe/prelim/xe_gt_debug.c | 72 +++++++++++++++-------
 drivers/gpu/drm/xe/prelim/xe_gt_debug.h |  5 +-
 drivers/gpu/drm/xe/regs/xe_gt_regs.h    |  4 +-
 4 files changed, 101 insertions(+), 59 deletions(-)

diff --git a/drivers/gpu/drm/xe/prelim/xe_eudebug.c b/drivers/gpu/drm/xe/prelim/xe_eudebug.c
index 75838c76b..3c4cdc526 100644
--- a/drivers/gpu/drm/xe/prelim/xe_eudebug.c
+++ b/drivers/gpu/drm/xe/prelim/xe_eudebug.c
@@ -2056,32 +2056,35 @@ struct ss_iter {
 };

 static int check_attn_mcr(struct xe_gt *gt, void *data,
-			  u16 group, u16 instance)
+			  u16 group, u16 instance, bool present)
 {
 	struct ss_iter *iter = data;
 	struct xe_eudebug *d = iter->debugger;
-	unsigned int row;
+	unsigned int reg, row;

-	for (row = 0; row < PRELIM_TD_EU_ATTENTION_MAX_ROWS; row++) {
-		u32 val, cur = 0;
+	for (reg = 0; reg < xe_gt_eu_att_regs(gt); reg++) {
+		for (row = 0; row < PRELIM_TD_EU_ATTENTION_MAX_ROWS; row++) {
+			u32 val, cur = 0;

-		if (iter->i >= iter->size)
-			return 0;
+			if (iter->i >= iter->size)
+				return 0;

-		if (XE_WARN_ON((iter->i + sizeof(val)) >
-				(prelim_xe_gt_eu_attention_bitmap_size(gt))))
-			return -EIO;
+			if (XE_WARN_ON((iter->i + sizeof(val)) >
+				       (prelim_xe_gt_eu_attention_bitmap_size(gt))))
+				return -EIO;

-		memcpy(&val, &iter->bits[iter->i], sizeof(val));
-		iter->i += sizeof(val);
+			memcpy(&val, &iter->bits[iter->i], sizeof(val));
+			iter->i += sizeof(val);

-		cur = xe_gt_mcr_unicast_read(gt, TD_ATT(row), group, instance);
+			if (present)
+				cur = xe_gt_mcr_unicast_read(gt, EU_ATT(reg, row), group, instance);

-		if ((val | cur) != cur) {
-			eu_dbg(d,
-			       "WRONG CLEAR (%u:%u:%u) TD_CRL: 0x%08x; TD_ATT: 0x%08x\n",
-			       group, instance, row, val, cur);
+			if ((val | cur) != cur) {
+				eu_dbg(d,
+				       "WRONG CLEAR (%u:%u:%u:%u) TD_CRL: 0x%08x; TD_ATT: 0x%08x\n",
+				       group, instance, reg, row, val, cur);
 			return -EINVAL;
+			}
 		}
 	}

@@ -2089,34 +2092,42 @@ static int check_attn_mcr(struct xe_gt *gt, void *data,
 }

 static int clear_attn_mcr(struct xe_gt *gt, void *data,
-			  u16 group, u16 instance)
+			  u16 group, u16 instance, bool present)
 {
 	struct ss_iter *iter = data;
 	struct xe_eudebug *d = iter->debugger;
-	unsigned int row;
+	unsigned int reg, row;

-	for (row = 0; row < PRELIM_TD_EU_ATTENTION_MAX_ROWS; row++) {
-		u32 val;
+	for (reg = 0; reg < xe_gt_eu_att_regs(gt); reg++) {
+		for (row = 0; row < PRELIM_TD_EU_ATTENTION_MAX_ROWS; row++) {
+			u32 val;

-		if (iter->i >= iter->size)
-			return 0;
+			if (iter->i >= iter->size)
+				return 0;

-		if (XE_WARN_ON((iter->i + sizeof(val)) >
-				(prelim_xe_gt_eu_attention_bitmap_size(gt))))
-			return -EIO;
+			if (XE_WARN_ON((iter->i + sizeof(val)) >
+				       (prelim_xe_gt_eu_attention_bitmap_size(gt))))
+				return -EIO;

-		memcpy(&val, &iter->bits[iter->i], sizeof(val));
-		iter->i += sizeof(val);
+			memcpy(&val, &iter->bits[iter->i], sizeof(val));
+			iter->i += sizeof(val);

-		if (!val)
-			continue;
+			if (!val)
+				continue;

-		xe_gt_mcr_unicast_write(gt, TD_CLR(row), val,
-					group, instance);
+			if (present) {
+				xe_gt_mcr_unicast_write(gt, EU_ATT_CLR(reg, row), val,
+							group, instance);

-		eu_dbg(d,
-		       "TD_CLR: (%u:%u:%u): 0x%08x\n",
-		       group, instance, row, val);
+				eu_dbg(d,
+				       "EU_ATT_CLR: (%u:%u:%u:%u): 0x%08x\n",
+				       group, instance, reg, row, val);
+			} else {
+				eu_warn(d,
+					"EU_ATT_CLR: (%u:%u:%u:%u): 0x%08x\n",
+					group, instance, reg, row, val);
+			}
+		}
 	}

 	return 0;
diff --git a/drivers/gpu/drm/xe/prelim/xe_gt_debug.c b/drivers/gpu/drm/xe/prelim/xe_gt_debug.c
index 1a17a8dd2..2f34d834c 100644
--- a/drivers/gpu/drm/xe/prelim/xe_gt_debug.c
+++ b/drivers/gpu/drm/xe/prelim/xe_gt_debug.c
@@ -14,14 +14,21 @@
 #include "xe_pm.h"
 #include "xe_macros.h"

+unsigned int xe_gt_eu_att_regs(struct xe_gt *gt)
+{
+	return (GRAPHICS_VERx100(gt_to_xe(gt)) >= 3000) ? 2u : 1u;
+}
+
 int prelim_xe_gt_foreach_dss_group_instance(struct xe_gt *gt,
 				     int (*fn)(struct xe_gt *gt,
 					       void *data,
 					       u16 group,
-					       u16 instance),
+					       u16 instance,
+					       bool present),
 				     void *data)
 {
 	const enum xe_force_wake_domains fw_domains = XE_FW_GT;
+	xe_dss_mask_t dss_mask;
 	unsigned int dss, fw_ref;
 	u16 group, instance;
 	int ret = 0;
@@ -30,8 +37,19 @@ int prelim_xe_gt_foreach_dss_group_instance(struct xe_gt *gt,
 	if (!fw_ref)
 		return -ETIMEDOUT;

-	for_each_dss_steering(dss, gt, group, instance) {
-		ret = fn(gt, data, group, instance);
+	bitmap_or(dss_mask, gt->fuse_topo.g_dss_mask, gt->fuse_topo.c_dss_mask,
+		  XE_MAX_DSS_FUSE_BITS);
+
+	/*
+	 * Note: This removes terminating zeros when last dss is fused out!
+	 * In order bitmask to be exactly the same as on with i915 we would
+	 * need to figure out max dss for given platform, most probably by
+	 * querying hwconfig
+	 */
+	for (dss = 0; dss <= find_last_bit(dss_mask, XE_MAX_DSS_FUSE_BITS); dss++) {
+		xe_gt_mcr_get_dss_steering(gt, dss, &group, &instance);
+
+		ret = fn(gt, data, group, instance, test_bit(dss, dss_mask));
 		if (ret)
 			break;
 	}
@@ -42,17 +60,22 @@ int prelim_xe_gt_foreach_dss_group_instance(struct xe_gt *gt,
 }

 static int read_first_attention_mcr(struct xe_gt *gt, void *data,
-				    u16 group, u16 instance)
+				    u16 group, u16 instance, bool present)
 {
-	unsigned int row;
+	unsigned int reg, row;

-	for (row = 0; row < 2; row++) {
-		u32 val;
+	if (!present)
+		return 0;

-		val = xe_gt_mcr_unicast_read(gt, TD_ATT(row), group, instance);
+	for (reg = 0; reg < xe_gt_eu_att_regs(gt); reg++) {
+		for (row = 0; row < PRELIM_TD_EU_ATTENTION_MAX_ROWS; row++) {
+			u32 val = 0;

-		if (val)
-			return 1;
+			val = xe_gt_mcr_unicast_read(gt, EU_ATT(reg, row), group, instance);
+
+			if (val)
+				return 1;
+		}
 	}

 	return 0;
@@ -75,8 +98,8 @@ int prelim_xe_gt_eu_attention_bitmap_size(struct xe_gt *gt)
 	bitmap_or(dss_mask, gt->fuse_topo.c_dss_mask,
 		  gt->fuse_topo.g_dss_mask, XE_MAX_DSS_FUSE_BITS);

-	return  bitmap_weight(dss_mask, XE_MAX_DSS_FUSE_BITS) *
-		PRELIM_TD_EU_ATTENTION_MAX_ROWS * MAX_THREADS *
+	return  (find_last_bit(dss_mask, XE_MAX_DSS_FUSE_BITS) + 1) *
+		PRELIM_TD_EU_ATTENTION_MAX_ROWS * xe_gt_eu_att_regs(gt) * MAX_THREADS *
 		MAX_EUS_PER_ROW / 8;
 }

@@ -88,23 +111,28 @@ struct attn_read_iter {
 };

 static int read_eu_attentions_mcr(struct xe_gt *gt, void *data,
-				  u16 group, u16 instance)
+				  u16 group, u16 instance, bool present)
 {
 	struct attn_read_iter * const iter = data;
-	unsigned int row;
+	unsigned int reg, row;

-	for (row = 0; row < PRELIM_TD_EU_ATTENTION_MAX_ROWS; row++) {
-		u32 val;
+	for (reg = 0; reg < xe_gt_eu_att_regs(gt); reg++) {
+		for (row = 0; row < PRELIM_TD_EU_ATTENTION_MAX_ROWS; row++) {
+			u32 val;

-		if (iter->i >= iter->size)
-			return 0;
+			if (iter->i >= iter->size)
+				return 0;

-		XE_WARN_ON(iter->i + sizeof(val) > prelim_xe_gt_eu_attention_bitmap_size(gt));
+			XE_WARN_ON(iter->i + sizeof(val) > prelim_xe_gt_eu_attention_bitmap_size(gt));

-		val = xe_gt_mcr_unicast_read(gt, TD_ATT(row), group, instance);
+			if (present)
+				val = xe_gt_mcr_unicast_read(gt, EU_ATT(reg, row), group, instance);
+			else
+				val = 0;

-		memcpy(&iter->bits[iter->i], &val, sizeof(val));
-		iter->i += sizeof(val);
+			memcpy(&iter->bits[iter->i], &val, sizeof(val));
+			iter->i += sizeof(val);
+		}
 	}

 	return 0;
diff --git a/drivers/gpu/drm/xe/prelim/xe_gt_debug.h b/drivers/gpu/drm/xe/prelim/xe_gt_debug.h
index 6256e1e64..d63f634a1 100644
--- a/drivers/gpu/drm/xe/prelim/xe_gt_debug.h
+++ b/drivers/gpu/drm/xe/prelim/xe_gt_debug.h
@@ -23,12 +23,15 @@ struct xe_eu_attentions {
 	ktime_t ts;
 };

+unsigned int xe_gt_eu_att_regs(struct xe_gt *gt);
+
 int prelim_xe_gt_eu_threads_needing_attention(struct xe_gt *gt);
 int prelim_xe_gt_foreach_dss_group_instance(struct xe_gt *gt,
 				     int (*fn)(struct xe_gt *gt,
 					       void *data,
 					       u16 group,
-					       u16 instance),
+					       u16 instance,
+					       bool present),
 				     void *data);

 int prelim_xe_gt_eu_attention_bitmap_size(struct xe_gt *gt);
diff --git a/drivers/gpu/drm/xe/regs/xe_gt_regs.h b/drivers/gpu/drm/xe/regs/xe_gt_regs.h
index da2433542..01bb2bcd0 100644
--- a/drivers/gpu/drm/xe/regs/xe_gt_regs.h
+++ b/drivers/gpu/drm/xe/regs/xe_gt_regs.h
@@ -485,7 +485,7 @@
 #define   DISABLE_ECC				REG_BIT(5)
 #define   ENABLE_PREFETCH_INTO_IC		REG_BIT(3)

-#define TD_ATT(x)				XE_REG_MCR(0xe470 + (x) * 4)
+#define EU_ATT(reg, row)			XE_REG_MCR((reg ? 0xe478 : 0xe470) + (row) * 4)

 #define ROW_CHICKEN4				XE_REG_MCR(0xe48c, XE_REG_OPTION_MASKED)
 #define   DISABLE_GRF_CLEAR			REG_BIT(13)
@@ -496,7 +496,7 @@
 #define   THREAD_EX_ARB_MODE			REG_GENMASK(3, 2)
 #define   THREAD_EX_ARB_MODE_RR_AFTER_DEP	REG_FIELD_PREP(THREAD_EX_ARB_MODE, 0x2)

-#define TD_CLR(i)				XE_REG_MCR(0xe490 + (i) * 4)
+#define EU_ATT_CLR(reg, row)			XE_REG_MCR((reg ? 0xe698 : 0xe490) + (row) * 4)

 #define ROW_CHICKEN3				XE_REG_MCR(0xe49c, XE_REG_OPTION_MASKED)
 #define   XE2_EUPEND_CHK_FLUSH_DIS		REG_BIT(14)
--
2.43.0
